---
title: 贝叶斯优化基本原理总结
tags:
- 机器学习
- 最优化
categories:
- 教程

---

# 黑盒优化问题
贝叶斯优化（Bayesian Optimization），主要用来解决计算成本昂贵的黑盒优化问题，这种问题有着以下两个特点：

1. 目标函数$$f(x)$$及其导数未知，否则就可以用梯度下降等方法求解
1. 计算目标函数时间成本大，意味着像蚁群算法、遗传算法这种方法也失效了，因为计算一次要花费很多时间

![image.png](https://cdn.nlark.com/yuque/0/2022/png/764062/1642518880682-ca49f801-c6dd-406d-965d-9ba3690c74a6.png#clientId=u3fe6f5be-444f-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=52&id=SNVtL)<br />这种问题最典型的就是机器学习里面的超参数优化，使用的模型为 $$f$$，超参数为输入的 $$x$$，评估指标（MSE, AUC等）为输出的目标函数值，在这个场景下，很多机器学习的入门课程都会提到网格搜索和随机搜索，但是这两个其实本质上也是一种类似于穷举的方式，随便选取一组可能的$$x$$，然后分别计算目标值，最后对比所有的结果得到最好的解，可以看出来这种求解是很低效的，因此，解决这种问题需要设计一种高效的算法，来在有限的时间里面找到一个相对不错的解，这就是贝叶斯优化。<br />贝叶斯优化，是一种使用贝叶斯定理来指导搜索以找到目标函数的最小值或最大值的方法，就是在每次迭代的时候，利用之前观测到的历史信息（先验知识)来进行下一次优化，通俗点讲，就是在进行一次迭代的时候，先回顾下之前的迭代结果，结果太差的$$x$$附近就不去找了，尽量往结果好一点的$$x$$附近去找最优解，这样一来搜索的效率就大大提高了，这其实和人的思维方式也有点像，每次在学习中试错，并且在下次的时候根据这些经验来找到最优的策略。
<a name="raVsx"></a>



# 贝叶斯优化过程

首先，假设有一个这样的函数$$c(x)$$，我们需要找到他的最小值，如下图所示，这也是我们所需要优化的目标函数，但是我们并不能够知道他的具体形状以及表达形式是怎么样的。<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/764062/1642862207488-61095c80-c151-4cb2-848d-74c44f23901f.png#clientId=u86233cce-d6bd-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u10477eea)<br />贝叶斯优化是通过一种叫做代理优化的方式来进行的，就是不知道真实的目标函数长什么样，我们就用一个代理函数（surrogate function）来代替目标函数，而这个代理函数就可以通过先采样几个点，再通过这几个点来给他拟合出来，如下图虚线所示：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/764062/1642862350662-cfeab91b-ee4f-4395-8cae-1c9c1df4d8c1.png#clientId=u86233cce-d6bd-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u93bcdc6a)<br />基于构造的代理函数，我们就可以在可能是最小值的点附近采集更多的点，或者在还没有采样过的区域来采集更多的点，有了更多点，就可以更新代理函数，使之更逼近真实的目标函数的形状，这样的话也更容易找到目标函数的最小值，这个采样的过程同样可以通过构建一个采集函数来表示，也就是知道了当前代理函数的形状，如何选择下一个$$x$$使得收益最大。<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/764062/1642862456555-21005371-dd1b-419e-9c9c-2c4e28d83ddf.png#clientId=u86233cce-d6bd-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uc7daab55)<br />然后重复以上过程，最终就可以找到函数的最小值点了，这大致就是贝叶斯优化的一个过程：

1. 初始化一个代理函数的先验分布
1. 选择数据点$$x$$，使得采集函数$$a(x)$$取最大值
1. 在目标函数 $$c(x)$$中评估数据点$$x$$并获取其结果 $$y$$
1. 使用新数据$$(x,y)$$更新代理函数，得到一个后验分布（作为下一步的先验分布）
1. 重复2-4步，直到达到最大迭代次数

举个例子，如图所示，一开始只有两个点（t=2），代理函数的分布是紫色的区域那块，然后根据代理函数算出一个采集函数（绿色线），取采集函数的最大值所在的$$x$$（红色三角处），算出$$y$$，然后根据新的点$$(x,y)$$更新代理函数和采集函数（t=3），继续重复上面步骤，选择新的采集函数最大值所在的$$x$$，算出$$y$$，再更新代理函数和采集函数，然后继续迭代<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/764062/1642870783116-4e643df2-ec8f-4b2c-84e2-f5d11c2cfac2.png#clientId=u86233cce-d6bd-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u912a5632)<br />问题的核心就在于代理函数和采集函数如何构建，常用的代理函数有：

1. 高斯过程（Gaussian processes）
1. Tree Parzer Estimator
1. 概率随机森林：针对类别型变量

采集函数则需要兼顾两方面的性质：

1. 利用当前已开发的区域（Exploitation）：即在当前最小值附近继续搜索
1. 探索尚未开发的区域（Exploration）：即在还没有搜索过的区域里面搜索，可能那里才是全局最优解

常用的采集函数有：

1. Probability of improvement（PI）

1. Expected improvement（EI）

1. Confidence bound criteria，包括LCB和UCB
  <a name="lYgNb"></a>

  
# 可用的贝叶斯优化框架

1. BayesianOptimization：[https://github.com/fmfn/BayesianOptimization](https://github.com/fmfn/BayesianOptimization)
1. 清华开源的openbox：[https://open-box.readthedocs.io/zh_CN/latest/index.html](https://open-box.readthedocs.io/zh_CN/latest/index.html)
1. 华为开源的HEBO：[https://github.com/huawei-noah/HEBO](https://github.com/huawei-noah/HEBO)
1. Hyperopt：[http://hyperopt.github.io/hyperopt/](http://hyperopt.github.io/hyperopt/)

个人觉得1和2就挺好用的
<a name="ZDkC6"></a>



# 参考

1. [https://towardsdatascience.com/the-beauty-of-bayesian-optimization-explained-in-simple-terms-81f3ee13b10f](https://towardsdatascience.com/the-beauty-of-bayesian-optimization-explained-in-simple-terms-81f3ee13b10f)
1. [https://chengfeng96.com/blog/2019/09/08/%E8%B4%9D%E5%8F%B6%E6%96%AF%E4%BC%98%E5%8C%96%E7%AC%94%E8%AE%B0/](https://chengfeng96.com/blog/2019/09/08/%E8%B4%9D%E5%8F%B6%E6%96%AF%E4%BC%98%E5%8C%96%E7%AC%94%E8%AE%B0/)
1. [https://zhuanlan.zhihu.com/p/459110020](https://zhuanlan.zhihu.com/p/459110020)
